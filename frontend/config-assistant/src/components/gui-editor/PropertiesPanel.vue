<script setup lang="ts">
import type {Ref} from 'vue';
import {ref, watch} from 'vue';
import TreeTable from 'primevue/treetable';
import Column from 'primevue/column';
import InputText from 'primevue/inputtext';
import Button from 'primevue/button';

import type {JsonSchema} from '@/helpers/schema/JsonSchema';
import PropertyData from '@/components/gui-editor/PropertyData.vue';
import PropertyMetadata from '@/components/gui-editor/PropertyMetadata.vue';
import {ConfigTreeNodeResolver} from '@/components/gui-editor/ConfigTreeNodeResolver';
import type {Path} from '@/model/path';
import {GuiConstants} from '@/constants';
import {ConfigTreeNodeData, GuiEditorTreeNode, TreeNodeType} from '@/model/ConfigDataTreeNode';
import {storeToRefs} from 'pinia';
import {useSessionStore} from '@/store/sessionStore';
import {pathToString} from '@/helpers/pathHelper';
import SchemaInfoOverlay from '@/components/gui-editor/SchemaInfoOverlay.vue';
import {refDebounced, useDebounceFn} from '@vueuse/core';
import {isObjectStructureEqual} from '@/helpers/compareObjectStructure';
import type {TreeNode} from 'primevue/tree';

const props = defineProps<{
  currentSchema: JsonSchema;
  currentData: any;
  currentPath: Path;
}>();

const emit = defineEmits<{
  (e: 'update_current_path', new_path: Path): void;
  (e: 'zoom_into_path', path_to_add: Path): void;
  (e: 'update_data', path: Path, newValue: any): void;
}>();

const treeNodeResolver = new ConfigTreeNodeResolver();

const loading = ref(false);
const loadingDebounced = refDebounced(loading, 100);

const treeTableFilters = ref<Record<string, string>>({});
const {currentExpandedElements} = storeToRefs(useSessionStore());

const currentTree = ref({});

function computeTree() {
  currentTree.value = treeNodeResolver.createTreeNodeOfProperty(
    props.currentSchema,
    undefined,
    props.currentPath
  );
  currentTree.value.children = treeNodeResolver.createChildNodesOfNode(currentTree.value);

  expandPreviouslyExpandedElements(currentTree.value.children as Array<GuiEditorTreeNode>);

  return currentTree.value;
}

/**
 * Calculate the children of all nodes that are expanded.
 * @param nodes initial nodes
 */
function expandPreviouslyExpandedElements(nodes: Array<GuiEditorTreeNode>) {
  for (const node of nodes) {
    const expanded = currentExpandedElements.value[pathToString(node.data.absolutePath)] ?? false;
    if (expanded) {
      node.children = treeNodeResolver.createChildNodesOfNode(node);
      if (node.children && node.children.length > 0) {
        expandPreviouslyExpandedElements(node.children as Array<GuiEditorTreeNode>);
      }
    }
  }
}

function updateTree() {
  loadingDebounced.value = true;
  window.setTimeout(() => {
    nodesToDisplay.value = computeTree().children;
    loadingDebounced.value = false;
  }, 0);
}

const nodesToDisplay: Ref<TreeNode[]> = ref(computeTree().children);

watch(storeToRefs(useSessionStore()).fileSchema, () => {
  currentExpandedElements.value = {};
  updateTree();
});

// recalculate the tree when the data structure changes, but not
// single values (e.g. when a property is changed)
watch(storeToRefs(useSessionStore()).fileData, (value, oldValue) => {
  if (!isObjectStructureEqual(value, oldValue)) {
    updateTree();
  }
});

watch(
  storeToRefs(useSessionStore()).currentSelectedOneOfAnyOfOptions,
  () => {
    updateTree();
  },
  {deep: true}
);

function updateData(subPath: Path, newValue: any) {
  const completePath = props.currentPath.concat(subPath);
  emit('update_data', completePath, newValue);
}

function focus(id: string) {
  window.setTimeout(function () {
    const element = document.getElementById(id);
    if (element) {
      element.focus();
    }
  }, 0);
}

function addItem(relativePath: Path, newValue: any) {
  updateData(relativePath, newValue);
  updateTree();
  const absolutePath = props.currentPath.concat(relativePath);

  // TODO fix parent path, not absolute Path
  const subSchema = props.currentSchema.subSchemaAt(
    relativePath,
    absolutePath.slice(0, -relativePath.length)
  );
  if (subSchema?.hasType('object') || subSchema?.hasType('array')) {
    useSessionStore().expand(absolutePath);

    window.setTimeout(() => {
      focusOnFirstProperty(relativePath);
    }, 0);
    return;
  }

  // focus on "add item" element (which id is the path of the array + 1
  // on the last element of the path)
  const pathToAddItem = relativePath.slice(0, -1).concat(relativePath[relativePath.length - 1] + 1);
  focus(pathToString(props.currentPath.concat(pathToAddItem)));
}

/**
 * Focus on the first property of the current tree or the first property of the given relative path.
 * @param relativePath the relative path to the property to focus on
 */
function focusOnFirstProperty(relativePath?: Path) {
  let pathToFirstProperty = currentTree.value.children[0]?.data?.absolutePath;

  if (relativePath) {
    const node = findNode(relativePath);
    if (node) {
      pathToFirstProperty = node.children[0]?.data?.absolutePath;
    }
  }
  if (pathToFirstProperty) {
    focus(pathToString(pathToFirstProperty));
  }
}

/**
 * Find a node in the current tree by its relative path.
 * @param relativePath the relative path of the node to find
 * @param root the root of the tree to search in
 */
function findNode(relativePath, root = currentTree.value) {
  const absolutePath = pathToString(props.currentPath.concat(relativePath));
  if (root.key === absolutePath) {
    return root;
  }

  for (const child of root.children) {
    const foundNode = findNode(relativePath, child);
    if (foundNode) {
      return foundNode;
    }
  }
  return undefined;
}

/**
 * Function for adding an empty value to an array.
 * This function is called when the user clicks on the "add item" button.
 */
function addEmptyArrayEntry(relativePath: Path, absolutePath: Path) {
  const relativePathOfArray = relativePath.slice(0, -1);
  const absolutePathOfArray = absolutePath.slice(0, -relativePathOfArray.length);
  const arraySchema = props.currentSchema.subSchemaAt(relativePathOfArray, absolutePathOfArray);

  if (!arraySchema?.items) {
    // TODO: handle this case
    return {};
  }
  if (arraySchema.items.hasType('object')) {
    addItem(relativePath, {});
  } else if (arraySchema.items.hasType('array')) {
    addItem(relativePath, []);
  } else if (arraySchema.items.hasType('string')) {
    addItem(relativePath, '');
  } else if (arraySchema.items.hasType('number') || arraySchema.items.hasType('integer')) {
    addItem(relativePath, 0);
  } else if (arraySchema.items.hasType('boolean')) {
    addItem(relativePath, false);
  }
}

/**
 * Returns a style object that adds negative margin to the table cells,
 * depending on the depth of the tree node.
 * This is required to make the table look like a table.
 *
 * @param depth depth of the tree node
 */
function addNegativeMarginForTableStyle(depth: number) {
  return {'margin-right': `${-depth * GuiConstants.INDENTATION_STEP}px`};
}

watch(storeToRefs(useSessionStore()).currentPath, (path: Path) => {
  updateTree();
  focusOnFirstProperty();
});

function displayAsRegularProperty(node: any) {
  return (
    node.type === TreeNodeType.PATTERN_PROPERTY ||
    node.type === TreeNodeType.SCHEMA_PROPERTY ||
    node.type === TreeNodeType.ADDITIONAL_PROPERTY
  );
}

function expandElement(node: any) {
  currentExpandedElements.value[node.key] = true;
  node.children = treeNodeResolver.createChildNodesOfNode(node);
  expandPreviouslyExpandedElements(node.children as Array<GuiEditorTreeNode>);
}

const schemaInfoOverlay = ref<InstanceType<typeof SchemaInfoOverlay> | undefined>();
const overlayVisible = ref(false);

const showInfoOverlayPanelInstantly = (nodeData: ConfigTreeNodeData, event: MouseEvent) => {
  // @ts-ignore
  schemaInfoOverlay.value?.showPanel(nodeData.schema, nodeData.name, nodeData.parentSchema, event);
};
const showInfoOverlayPanelDebounced = useDebounceFn((nodeData: ConfigTreeNodeData, event) => {
  if (overlayVisible.value) {
    showInfoOverlayPanelInstantly(nodeData, event);
  }
}, 500);

function showInfoOverlayPanel(nodeData: ConfigTreeNodeData, event) {
  overlayVisible.value = true;
  showInfoOverlayPanelDebounced(nodeData, event);
}

const closeInfoOverlayPanelDebounced = useDebounceFn(() => {
  // @ts-ignore
  schemaInfoOverlay.value?.closePanel();
}, 100);

function closeInfoOverlayPanel() {
  overlayVisible.value = false;
  closeInfoOverlayPanelDebounced();
}
</script>

<template>
  <SchemaInfoOverlay ref="schemaInfoOverlay" @hide="overlayVisible = false" />
  <TreeTable
    :value="nodesToDisplay"
    filter-mode="lenient"
    removable-sort
    resizable-columns
    scrollable
    scroll-direction="vertical"
    scroll-height="flex"
    row-hover
    :lazy="true"
    :loading="loading"
    :expandedKeys="currentExpandedElements"
    @nodeExpand="expandElement"
    @nodeCollapse="node => delete currentExpandedElements[node.key]"
    :filters="treeTableFilters">
    <!-- Filter field -->
    <template #header>
      <div class="text-left">
        <div class="p-input-icon-left w-full">
          <i class="pi pi-search" />
          <InputText
            v-model="treeTableFilters['global']"
            placeholder="Search for properties or data"
            class="h-8 w-80" />
        </div>
      </div>
    </template>
    <Column field="name" header="Property" :sortable="true" expander>
      <template #body="slotProps">
        <!-- data nodes, note: wrapping in another span breaks the styling completely -->
        <span
          v-if="displayAsRegularProperty(slotProps.node)"
          style="width: 50%; min-width: 50%"
          :style="addNegativeMarginForTableStyle(slotProps.node.data.depth)"
          @mouseenter="event => showInfoOverlayPanel(slotProps.node.data, event)"
          @mouseleave="closeInfoOverlayPanel">
          <PropertyMetadata
            :nodeData="slotProps.node.data"
            :type="slotProps.node.type"
            @zoom_into_path="path_to_add => $emit('zoom_into_path', path_to_add)" />
        </span>

        <span v-if="displayAsRegularProperty(slotProps.node)" style="max-width: 50%" class="w-full">
          <PropertyData
            class="w-full"
            :nodeData="slotProps.node.data"
            @update_property_value="updateData"
            bodyClass="w-full"
            @keydown.ctrl.i="event => showInfoOverlayPanelInstantly(slotProps.node.data, event)" />
        </span>

        <!-- special tree nodes -->
        <span
          v-if="slotProps.node.type === TreeNodeType.ADD_ITEM"
          style="width: 50%; min-width: 50%"
          :style="addNegativeMarginForTableStyle(slotProps.node.data.depth)">
          <Button
            text
            severity="secondary"
            class="text-gray-500"
            style="margin-left: -0.75rem"
            @click="
              addEmptyArrayEntry(slotProps.node.data.relativePath, slotProps.node.data.absolutePath)
            "
            @keyup.enter="
              addEmptyArrayEntry(slotProps.node.data.relativePath, slotProps.node.data.absolutePath)
            ">
            <i class="pi pi-plus" />
            <span class="pl-2">Add item</span>
          </Button>
        </span>

        <span
          v-if="slotProps.node.type === TreeNodeType.ADD_ITEM"
          style="max-width: 50%"
          class="w-full">
          <PropertyData
            class="w-full"
            :nodeData="slotProps.node.data"
            @update_property_value="addItem"
            bodyClass="w-full" />
        </span>
      </template>
    </Column>
  </TreeTable>
</template>

<style scoped>
/* The following lines make the table cells take less space */
:deep(.p-treetable-tbody > tr > td) {
  padding: 0.1rem 0.5rem;
}

:deep(.p-treetable-header) {
  padding: 0.5rem 0.5rem;
}

:deep(.p-treetable-thead > tr > th) {
  padding: 0.5rem 0.5rem;
}

/* Prevent the expander from being cut off */
:deep(.p-treetable-toggler) {
  overflow: visible !important;
}

:deep(.p-button) {
  padding: 0 0.5rem;
}

:deep(.p-button-label) {
  font-weight: 500;
}
</style>
