/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */
export type JsonSchemaType = (CoreAndValidationSpecificationsMetaSchema1 &
  CoreAndValidationSpecificationsMetaSchema2) | boolean;
export type TopLevelSchema = JsonSchemaType & {
  $schema?: string;
  $id?: string;
  $vocabulary?: {
    [k: string]: boolean;
  },
  $defs?: {
    [k: string]: JsonSchemaType;
  }
}
export type CoreAndValidationSpecificationsMetaSchema1 = CoreVocabularyMetaSchema1 &
  ApplicatorVocabularyMetaSchema1 &
  UnevaluatedApplicatorVocabularyMetaSchema1 &
  ValidationVocabularyMetaSchema1 &
  MetaDataVocabularyMetaSchema1 &
  FormatVocabularyMetaSchemaForAnnotationResults1 &
  ContentVocabularyMetaSchema1;

export interface CoreVocabularyMetaSchema1 {
  $ref?: string;
  $anchor?: string;
  $dynamicRef?: string;
  $dynamicAnchor?: string;
  $comment?: string;
  [k: string]: unknown;
}
export interface ApplicatorVocabularyMetaSchema1 {
  /**
   * @minItems 1
   */
  prefixItems?: [
    JsonSchemaType,
    ...JsonSchemaType[]
  ];
  items?: JsonSchemaType;
  contains?: JsonSchemaType;
  additionalProperties?: JsonSchemaType;
  properties?: {
    [k: string]: JsonSchemaType;
  };
  patternProperties?: {
    [k: string]: JsonSchemaType;
  };
  dependentSchemas?: {
    [k: string]: JsonSchemaType;
  };
  propertyNames?: JsonSchemaType;
  if?: JsonSchemaType;
  then?: JsonSchemaType;
  else?: JsonSchemaType;
  /**
   * @minItems 1
   */
  allOf?: [
    JsonSchemaType,
    ...JsonSchemaType[]
  ];
  /**
   * @minItems 1
   */
  anyOf?: [
    JsonSchemaType,
    ...JsonSchemaType[]
  ];
  /**
   * @minItems 1
   */
  oneOf?: [
    JsonSchemaType,
    ...JsonSchemaType[]
  ];
  not?: JsonSchemaType;
  [k: string]: unknown;
}
export interface UnevaluatedApplicatorVocabularyMetaSchema1 {
  unevaluatedItems?: JsonSchemaType;
  unevaluatedProperties?: JsonSchemaType;
  [k: string]: unknown;
}
export interface ValidationVocabularyMetaSchema1 {
  type?: AllowedTypes,
  const?: unknown;
  enum?: unknown[];
  multipleOf?: number;
  maximum?: number;
  exclusiveMaximum?: number;
  minimum?: number;
  exclusiveMinimum?: number;
  maxLength?: number;
  minLength?: number;
  pattern?: string;
  maxItems?: number;
  minItems?: number;
  uniqueItems?: boolean;
  maxContains?: number;
  minContains?: number;
  maxProperties?: number;
  minProperties?: number;
  required?: string[];
  dependentRequired?: {
    [k: string]: string[];
  };
  [k: string]: unknown;
}
export interface MetaDataVocabularyMetaSchema1 {
  title?: string;
  description?: string;
  default?: unknown;
  deprecated?: boolean;
  readOnly?: boolean;
  writeOnly?: boolean;
  examples?: unknown[];
  [k: string]: unknown;
}
export interface FormatVocabularyMetaSchemaForAnnotationResults1 {
  format?: string;
  [k: string]: unknown;
}
export interface ContentVocabularyMetaSchema1 {
  contentEncoding?: string;
  contentMediaType?: string;
  contentSchema?: JsonSchemaType;
  [k: string]: unknown;
}
export interface CoreAndValidationSpecificationsMetaSchema2 {
  definitions?: {
    [k: string]: JsonSchemaType;
  };
  dependencies?: {
    [k: string]:
      | JsonSchemaType
      | string[];
  };
  $recursiveAnchor?: string;
  $recursiveRef?: string;
  [k: string]: unknown;
}
export type AllowedType = "array" | "boolean" | "integer" | "null" | "number" | "object" | "string";
export type AllowedTypes =
  | AllowedType
  | [
    AllowedType,
  ...(AllowedType)[]
];
