@inproceedings{jsonSchema,
author = {Pezoa, Felipe and Reutter, Juan L. and Suarez, Fernando and Ugarte, Mart\'{\i}n and Vrgo\v{c}, Domagoj},
title = {Foundations of JSON Schema},
year = {2016},
isbn = {9781450341431},
publisher = {International World Wide Web Conferences Steering Committee},
address = {Republic and Canton of Geneva, CHE},
url = {https://doi.org/10.1145/2872427.2883029},
doi = {10.1145/2872427.2883029},
abstract = {JSON -- the most popular data format for sending API requests and responses -- is still lacking a standardized schema or meta-data definition that allows the developers to specify the structure of JSON documents. JSON Schema is an attempt to provide a general purpose schema language for JSON, but it is still work in progress, and the formal specification has not yet been agreed upon. Why this could be a problem becomes evident when examining the behaviour of numerous tools for validating JSON documents against this initial schema proposal: although they agree on most general cases, when presented with the greyer areas of the specification they tend to differ significantly. In this paper we provide the first formal definition of syntax and semantics for JSON Schema and use it to show that implementing this layer on top of JSON is feasible in practice. This is done both by analysing the theoretical aspects of the validation problem and by showing how to set up and validate a JSON Schema for Wikidata, the central storage for Wikimedia.},
booktitle = {Proceedings of the 25th International Conference on World Wide Web},
pages = {263–273},
numpages = {11},
keywords = {expressiveness of schema languages, JSON schema, JSON validation, JSON},
location = {Montr\'{e}al, Qu\'{e}bec, Canada},
series = {WWW '16}
}

@article{barbaglia,
author = {Barbaglia, Guido and Murzilli, Simone and Cudini, Stefano},
title = {Definition of REST web services with JSON schema},
journal = {Software: Practice and Experience},
volume = {47},
number = {6},
pages = {907-920},
keywords = {JSON Schema, JSON Hyper Schema, REST, web services definition},
doi = {https://doi.org/10.1002/spe.2466},
url = {https://onlinelibrary.wiley.com/doi/abs/10.1002/spe.2466},
eprint = {https://onlinelibrary.wiley.com/doi/pdf/10.1002/spe.2466},
abstract = {Summary The Web has evolved from being a collection of documents to a collection of interconnected services that interoperate throughout the Internet. Web services are a natural consequence of this evolution. The web services model was initially centered around the eXtensible Markup Language (XML). Such services can be described by Web Services Description Language documents that are formally defined through the XML Schema Definition language. However, in recent years the popularity of XML-based web services has declined, as more developers favor JavaScript Object Notation (JSON)-based alternatives. Although the use of the latter language is spreading, no official standard to formally describe JSON documents exists. The aim of this article is to demonstrate how JSON Schema, and particularly the JSON Hyper Schema extension, is suitable to describe JSON-based web services that follow the REST architectural pattern. Copyright © 2016 John Wiley \& Sons, Ltd.},
year = {2017}
}

@article{ChaeronySiffa2022,
  doi = {10.12688/f1000research.110875.1},
  url = {https://doi.org/10.12688/f1000research.110875.1},
  year = {2022},
  month = apr,
  publisher = {F1000 Research Ltd},
  volume = {11},
  pages = {475},
  author = {Ihda Chaerony Siffa and Jan Sch\"{a}fer and Markus M. Becker},
  title = {Adamant: a {JSON} schema-based metadata editor for research data management workflows},
  journal = {F1000Research}
}

@misc{jsonschemaJSONSchema,
	author = {},
	title = {{J}{S}{O}{N} {S}chema --- json-schema.org},
	howpublished = {\url{https://json-schema.org}},
	year = {},
	note = {[Accessed 01-May-2023]},
}

@misc{protobufProtocolBuffers,
	author = {},
	title = {{P}rotocol {B}uffers --- protobuf.dev},
	howpublished = {\url{https://protobuf.dev}},
	year = {},
	note = {[Accessed 01-May-2023]},
}

@inproceedings{graphQL,
author = {Hartig, Olaf and Hidders, Jan},
title = {Defining Schemas for Property Graphs by Using the GraphQL Schema Definition Language},
year = {2019},
isbn = {9781450367899},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3327964.3328495},
doi = {10.1145/3327964.3328495},
abstract = {GraphQL is a highly popular new approach to build Web APIs. An important component of this approach is the GraphQL schema definition language (SDL). The original purpose of this language is to define a so-called GraphQL schema that specifies the types of objects that can be queried when accessing a specific GraphQL Web API. This paper focuses on the question: Can we repurpose this language to define schemas for graph databases that are based on the Property Graph model? This question is relevant because there does not exist a commonly adopted approach to define schemas for Property Graphs, and because the form in which GraphQL APIs represent their underlying data sources is very similar to the Property Graph model. To answer the question we propose an approach to adopt the GraphQL SDL for Property Graph schemas. We define this approach formally and show its fundamental properties.},
booktitle = {Proceedings of the 2nd Joint International Workshop on Graph Data Management Experiences \& Systems (GRADES) and Network Data Analytics (NDA)},
articleno = {6},
numpages = {11},
keywords = {schema, constraints, graph database},
location = {Amsterdam, Netherlands},
series = {GRADES-NDA'19}
}

@misc{JSONValidation,   
    title = {JSON Schema Validation: A Vocabulary for Structural Validation of JSON},   
    url = {https://json-schema.org/draft/2019-09/json-schema-validation.html},   
    author = {A. Wright, H. Andrews, B. Hutton},   
    year = {March 20, 2020},   
    note = {Accessed 06-May-2023} 
}

@misc{python-cerberus,   
    title = {Cerberus},   
    url = {https://docs.python-cerberus.org/en/stable/schemas.html#},   
    author = {Nicola Iarocci, Frank Sachsenheim},   
    year = {},   
    note = {Accessed 06-May-2023} 
}

@misc{Yamale,   
    title = {Yamale},   
    url = {https://github.com/23andMe/Yamale#examples},   
    author = {Bo Lopker},   
    year = {},   
    note = {Accessed 06-May-2023} 
}

@misc{githubGitHubJsonsystemspublic,
	author = {{J}ack Wootton},
	title = {JSON Systems --- github.com},
	howpublished = {\url{https://github.com/jsonsystems/public}},
	year = {},
	note = {[Accessed 07-May-2023]},
}

@misc{githubGitHubSaasquatchjsonschemainferrer,
	author = {},
	title = {{G}it{H}ub - saasquatch/json-schema-inferrer: {J}ava library for inferring {J}{S}{O}{N} schema from sample {J}{S}{O}{N}s --- github.com},
	howpublished = {\url{https://github.com/saasquatch/json-schema-inferrer}},
	year = {},
	note = {[Accessed 07-May-2023]},
}

@INPROCEEDINGS{8424731,
  author={Frozza, Angelo Augusto and Mello, Ronaldo dos Santos and Costa, Felipe de Souza da},
  booktitle={2018 IEEE International Conference on Information Reuse and Integration (IRI)}, 
  title={An Approach for Schema Extraction of JSON and Extended JSON Document Collections}, 
  year={2018},
  volume={},
  number={},
  pages={356-363},
  doi={10.1109/IRI.2018.00060}}


  @article{klettke,
year = {2015},
month = {03},
pages = {425-444},
title = {Schema extraction and structural outlier detection for JSON-based NoSQL data stores},
author={Klettke, Meike and St{\"o}rl, Uta and Scherzinger, Stefanie},
  journal={Datenbanksysteme f{\"u}r Business, Technologie und Web (BTW 2015)},
  publisher={Gesellschaft f{\"u}r Informatik eV}
}

@article{Baazizi2019,
  doi = {10.1007/s00778-018-0532-7},
  url = {https://doi.org/10.1007/s00778-018-0532-7},
  year = {2019},
  month = jan,
  publisher = {Springer Science and Business Media {LLC}},
  volume = {28},
  number = {4},
  pages = {497--521},
  author = {Mohamed-Amine Baazizi and Dario Colazzo and Giorgio Ghelli and Carlo Sartiani},
  title = {Parametric schema inference for massive {JSON} datasets},
  journal = {The {VLDB} Journal}
}

@article{xml_schemas_1,
author = {Lee, Dongwon and Chu, Wesley W.},
title = {Comparative Analysis of Six XML Schema Languages},
year = {2000},
issue_date = {Sept. 2000},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {29},
number = {3},
issn = {0163-5808},
url = {https://doi.org/10.1145/362084.362140},
doi = {10.1145/362084.362140},
abstract = {As XML [5] is emerging as the data format of the internet era, there is an substantial increase of the amount of data in XML format. To better describe such XML data structures and constraints, several XML schema languages have been proposed. In this paper, we present a comparative analysis of six noteworthy XML schema languages.},
journal = {SIGMOD Rec.},
month = {sep},
pages = {76–87},
numpages = {12}
}

@article{xml_schemas_2,
author = {Martens, Wim and Neven, Frank and Niewerth, Matthias and Schwentick, Thomas},
title = {BonXai: Combining the Simplicity of DTD with the Expressiveness of XML Schema},
year = {2017},
issue_date = {September 2017},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {42},
number = {3},
issn = {0362-5915},
url = {https://doi.org/10.1145/3105960},
doi = {10.1145/3105960},
abstract = {While the migration from DTD to XML Schema was driven by a need for increased expressivity and flexibility, the latter was also significantly more complex to use and understand. Whereas DTDs are characterized by their simplicity, XML Schema Documents are notoriously difficult. In this article, we introduce the XML specification language BonXai, which incorporates many features of XML Schema but is arguably almost as easy to use as DTDs. In brief, the latter is achieved by sacrificing the explicit use of types in favor of simple patterns expressing contexts for elements. The goal of BonXai is not to replace XML Schema but rather to provide a simpler alternative for users who want to go beyond the expressiveness and features of DTD but do not need the explicit use of types. Furthermore, XML Schema processing tools can be used as a back-end for BonXai, since BonXai can be automatically converted into XML Schema. A particularly strong point of BonXai is its solid foundation rooted in a decade of theoretical work around pattern-based schemas. We present a formal model for a core fragment of BonXai and the translation algorithms to and from a core fragment of XML Schema. We prove that BonXai and XML Schema can be converted back-and-forth on the level of tree languages and we formally study the size trade-offs between the two languages.},
journal = {ACM Trans. Database Syst.},
month = {aug},
articleno = {15},
numpages = {42},
keywords = {XML, schema languages, XML Schema, BonXai}
}

@inproceedings{dtd_vs_xsd,
author = {Bex, Geert Jan and Neven, Frank and Van den Bussche, Jan},
title = {DTDs versus XML Schema: A Practical Study},
year = {2004},
isbn = {9781450377881},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/1017074.1017095},
doi = {10.1145/1017074.1017095},
abstract = {Among the various proposals answering the shortcomings of Document Type Definitions (DTDs), XML Schema is the most widely used. Although DTDs and XML Schema Definitions (XSDs) differ syntactically, they are still quite related on an abstract level. Indeed, freed from all syntactic sugar, XML Schemas can be seen as an extension of DTDs with a restricted form of specialization. In the present paper, we inspect a number of DTDs and XSDs harvested from the web and try to answer the following questions: (1) which of the extra features/expressiveness of XML Schema not allowed by DTDs are effectively used in practice; and, (2) how sophisticated are the structural properties (i.e. the nature of regular expressions) of the two formalisms. It turns out that at present real-world XSDs only sparingly use the new features introduced by XML Schema: on a structural level the vast majority of them can already be defined by DTDs. Further, we introduce a class of simple regular expressions and obtain that a surprisingly high fraction of the content models belong to this class. The latter result sheds light on the justification of simplifying assumptions that sometimes have to be made in XML research.},
booktitle = {Proceedings of the 7th International Workshop on the Web and Databases: Colocated with ACM SIGMOD/PODS 2004},
pages = {79–84},
numpages = {6},
location = {Paris, France},
series = {WebDB '04}
}

 @misc{probst_siegel_2023, title={Quicktype/quicktype: Generate types and converters from JSON, schema, and graphql}, url={https://github.com/quicktype/quicktype}, journal={GitHub}, author={Probst, Mark and Siegel, David}, year={2023}} 

 
 @misc{xsd_spec, title={XML Schema Part 0: Primer Second Edition - W3C Recommendation 28 October 2004}, url={https://www.w3.org/TR/2004/REC-xmlschema-0-20041028/}, journal={W3C}, author={Fallside, David and Walmsley, Priscilla}, year={2004}} 
 @misc{dtd_spec, title={W3C XML Specification DTD (“XMLspec”)}, url={https://www.w3.org/XML/1998/06/xmlspec-report-19980910.htm}, journal={W3C}, author={Bosak, Jon and Bray, Tim and Connolly, Dan and Maler, Eve and Nicol, Gabin and Sperberg-McQueen, Michael and Wood, Lauren and Clark, James}, year={1998}} 

 @misc{JSON_schema_vailidation,   
    title = {validation},   
    url = {https://json-schema.org/draft/2020-12/json-schema-validation.html#name-validation-keywords-for-any},   
    author = {A.Wright, H.Andrews Ed, B Hutton},   
    year = {18 December 2022},   
    note = {Accessed 18-May-2023} 
}

@misc{mostpopularides,
	author = {Pierre Carbonnelle},
	title = {{T}{O}{P} {I}{D}{E} {T}op {I}ntegrated {D}evelopment {E}nvironment index --- pypl.github.io},
	howpublished = {\url{https://pypl.github.io/IDE.html}},
	year = {},
	note = {[Accessed 18-May-2023]},
}

 @misc{JSONForms,   
    title = {scheme2gui},   
    url = {https://jsonforms.io/},   
    author = {Edgar Müller,Eugen Neufeld},   
    year = {},   
    note = {Accessed 18-May-2023} 
}

@misc{Vuejsonschemaform,   
    title = {Vue JSON Schema Form},   
    url = {https://roma219.github.io/vue-jsonschema-form/},   
    year = {},   
    note = {Accessed 18-May-2023} 
}

@article{siffa2022adamant,
  title={Adamant: a JSON schema-based metadata editor for research data management workflows},
  author={Siffa, Ihda Chaerony and Sch{\"a}fer, Jan and Becker, Markus M},
  journal={F1000Research},
  volume={11},
  year={2022},
  publisher={Faculty of 1000 Ltd}
}

@misc{cuelang,   
    title = {Configure Unify Execute},   
    url = {https://cuelang.org/},   
    year = {},   
    note = {Accessed 18-May-2023} 
}

@misc{vueformgenerator,   
    title = {Vue Form Generator},   
    url = {https://github.com/vue-generators/vue-form-generator},   
    year = {},   
    note = {Accessed 18-May-2023} 
}

@misc{baazizi2021empirical,
      title={An Empirical Study on the "Usage of Not" in Real-World JSON Schema Documents (Long Version)}, 
      author={Mohamed-Amine Baazizi and Dario Colazzo and Giorgio Ghelli and Carlo Sartiani and Stefanie Scherzinger},
      year={2021},
      eprint={2107.08677},
      archivePrefix={arXiv},
      primaryClass={cs.DB}
}

@misc{Viotti_Lagoni_2023, title={Sourcemeta/alterschema: Convert between JSON Schema Specification versions.}, url={https://github.com/sourcemeta/alterschema}, journal={GitHub}, author={Viotti, Juan Cruz and Lagoni, Jonas}, year={2023}} 

@misc{Apache-Avro,   
    title = {What is Apache Avro?},   
    url = {https://www.ibm.com/topics/avro},   
    year = {},   
    note = {Accessed 14-June-2023} 
}

