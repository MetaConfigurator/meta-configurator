\subsection{JSON and YAML}

\textit{JSON} is a common data-interchange format for exchanging data with web services, but also for storing documents in NoSQL databases, such as MongoDB\@\cite{marrs2017json}.
\textit{Schema languages} are formal languages that specify the structure, constraints, and relationships of data, for example in a database or structured data formats.
Schema languages exist for \textit{JSON}\cite{jsonSchema, jsonschemaJSONSchema,Apache-Avro,rfc8927,Kappestein_2023}, but also for other data formats, such as \textit{XML}\cite{dtd_spec, xsd_spec, xml_schemas_1, xml_schemas_2}.
In our initial (extended) paper about \toolname{}, we evaluated 8 different schema languages, measuring their \textit{practical usage} (\textit{popularity}, \textit{tool support}, \textit{library support}) and \textit{expressiveness}.
We found \textit{JSON Schema}~\cite{jsonSchema, jsonschemaJSONSchema} to be the one with most \textit{practical usage} and \textit{expressiveness}, which is why we based \toolname{} on it.\footnote{\url{https://github.com/logende/meta-configurator/paper/paper_main_extended.pdf} accessed 2024/04/27}

\subsubsection{JSON Schema}
Listing~\ref{lst:json-schema-example} shows an example of a JSON schema and listing~\ref{lst:json-example} shows an example of a JSON document that conforms to the schema.

JSON schema has evolved to being the de-facto standard schema language for JSON documents~\cite{baazizi2021empirical}.
Schemas for many popular \cfgfile{} types exist.
\textit{JSON schema store}\footnote{\url{https://www.schemastore.org/json/}, accessed 2024/01/22} is a website that provides over 600 JSON schema files for various use cases.
The supported file types include, for example, Docker compose or OpenAPI files.

We remark that JSON schema and other schema languages for JSON can also be applied to YAML, as JSON and YAML documents are of a similar structure (JSON is a subset of YAML).
Some syntactical details of YAML can, however, not be expressed with JSON schema.


\begin{lstlisting}[language=json,firstnumber=1,caption={JSON schema example},captionpos=b,label={lst:json-schema-example}]
{
  "$id": "https://example.org
  /person.schema.json",
  "$schema": "https://json-schema.org
  /draft/2020-12/schema",
  "title": "Person",
  "type": "object",
  "properties": {
    "firstName": {
      "type": "string",
      "description": "first name."
    },
    "lastName": {
      "type": "string",
      "description": "last name."
    },
    "age": {
      "description": "Age",
      "type": "integer",
      "minimum": 0
    }
  }
}
\end{lstlisting}


\begin{lstlisting}[language=json,firstnumber=1,caption={JSON example for the schema in listing}~\ref{lst:json-schema-example},captionpos=b,label={lst:json-example}]
{
  "firstName": "Alex",
  "lastName": "Smith",
  "age": 28
}
\end{lstlisting}



\subsubsection{Schema-based form generation} % or "form generation"?

The idea of generating a GUI from a schema is not new.
Early works in this area propose generating forms from XML schemas~\cite{kasarda2010generating, fenech2008semantic,
    kuo2005generating} or entity-relationship diagrams~\cite{bajaj2009user}.
There exist various approaches that generate web forms from the more modern format, JSON schema, e.g.,
\textit{React JSON Schema Form}\footnote{\url{https://github.com/rjsf-team/react-jsonschema-form}, accessed 2024/01/22.},
\textit{Angular Schema Form}\footnote{\url{https://github.com/json-schema-form/angular-schema-form}, accessed 2024/01/22.},
\textit{Vue Form Generator}\footnote{\url{https://github.com/vue-generators/vue-form-generator}, accessed 2024/01/22.},
\textit{JSON Forms}\footnote{\url{https://jsonforms.io}, accessed 2024/01/22.},
\textit{JSON Editor Online}\footnote{\url{https://jsoneditoronline.org}, accessed 2024/01/22.}, and
\textit{JSON Form}\footnote{\url{https://github.com/jsonform}, accessed 2024/01/22.}.

Such forms can assist the user in a multitude of ways, such as by tooltips, auto-completion, and dropdown menus.
By inherently adhering to the schema structure, editing data with such GUIs significantly reduces configuration mistakes caused by the user.
The generated forms usually have a specific component for each type of data, e.g., a text field for strings.




\subsubsection{Schema editors}
There exist several so-called schema editors, which are tools for creating and editing schemas that are text-based or graphical (or both).

\textit{JSON Editor Online}\footnote{\url{https://jsoneditoronline.org}, accessed 2024/01/22.} is a web-based editor for JSON schemas and JSON documents.
It divides the editor into two parts, where one part can be used to edit the schema and the other part can be used to edit a JSON document,
which is validated against the schema.
The editor provides various features, such as syntax highlighting and highlighting of validation errors. 
However, the features of the editor are limited.
For example, it does not provide any assistance for the user, such as tooltips or auto-completion.
For new documents, it does not show any properties of the schema, so the user has to know the schema beforehand

There also exists a variety of schema editors that are paid software, such as \textit{Altova XMLSpy}\footnote{\url{https://www.altova.com/xmlspy-xml-editor}, accessed 2024/01/22.},
\textit{Liquid Studio}\footnote{\url{https://www.liquid-technologies.com/json-schema-editor}, accessed 2024/01/22.}, \textit{XML ValidatorBuddy}\footnote{\url{https://www.xml-buddy.com/}, accessed 2024/01/22.},
\textit{JSONBuddy}\footnote{\url{https://www.json-buddy.com/}, accessed 2024/01/22.}, \textit{XMLBlueprint}\footnote{\url{https://www.xmlblueprint.com}, accessed 2024/01/22.},
and \textit{Oxygen XML Editor}\footnote{\url{https://www.oxygenxml.com}, accessed 2024/01/22.}.
Those are editors for XML or JSON schema, mostly with a combination of text-based and graphical views.
These tools are not web-based and not open-source.
Furthermore, they do not focus on editing a JSON document based on a schema,
but rather only on editing the schema itself.


\subsubsection{Adamant}
Adamant\footnote{Current version of Adamant as of writing this paper: Adamant v1.2.0} is a JSON Schema-based form generator and schema editor specifically designed for scientific data~\cite{siffa2022adamant}.
It generates a GUI from a JSON schema, allows editing and creating JSON schema documents, and differentiates between a schema edit mode and a data edit mode.
A noteworthy feature is that it supports the extraction of units from the description of a field, which is helpful for scientific data.

Besides the frontend, Adamant also provides a backend that allows the integration into other tools as well as storing and reusing schemas.
Adamants UI-based schema editor is intuitive and user-friendly, even for users who are not familiar with JSON schema.
However, Adamant does not provide a text based editor as an alternative to the GUI and does not support various JSON schema keywords.
For example, it is not possible to restrict strings to a certain regular expression and it does not support the keyword \texttt{oneOf}, which many schemas use~\cite{baazizi2021empirical}.


\subsubsection{Schema Visualization}\label{subsubsec:schema-visualization}
Generating a GUI from a schema is related to schema visualization, for which several techniques exist~\cite{frasincar2006adapting, silva2019visualization, deligiannidis2007rdf, north2002visualization}.
%TODO

\subsubsection{Schema-to-UML approaches}\label{subsubsec:schema-to-uml}
%TODO

\subsection{Ontologies}
In their paper "What Is an Ontology?" Guarino et al.\cite{guarino2009ontology} provide a definition for \textit{computational ontologies}, as it is applied in the knowledge engineering community.
\begin{quote}
	"Computational ontologies are a means to formally model the structure of a system, i.e., the relevant entities and relations that emerge from its observation, and which are useful to our purposes. An example of such a system can be a company with all its employees and their interrelationships. The ontology engineer analyzes relevant entities and organizes them into concepts and relations, being represented, respectively, by unary and binary predicates. The backbone of an ontology consists of a generalization/specialization hierarchy of concepts, i.e., a taxonomy. Supposing we are interested in aspects related to human resources, then Person, Manager, and Researcher might be relevant concepts, where the first is a superconcept of the latter two. Cooperates-with can be considered a relevant relation holding between persons. A concrete person working in a company would then be an instance of its corresponding concept."\cite{guarino2009ontology}
\end{quote}

In their article "Knowledge Graphs", Aidan et al. \cite{hogan2021knowledge} give a comprehensive summary on how knowledge graphs are being used, what techniques are employed and how they relate to existing data management topics.
They describe that representing data in a graph brings a number of benefits in settings that involve integrating, managing and extracting data from diverse sources at a large scale, compared to relational models.
Most notably, it enables more flexibility in the data and allows postponing the schema definition, it supports navigational operators for recursively finding entities connected through arbitrary-length paths and it enables new ways of reasoning about the data, supporting machine learning techniques directly working with the graph.
%\begin{quote}
%	"Graphs provide a concise and intuitive abstraction for a variety of domains, where edges capture the (potentially cyclical) relations between the entities inherent in social data, biological interactions, bibliographical citations and co-authorships, transport networks, and so forth. Graphs allow maintainers to postpone the definition of a schema, allowing the data – and its scope – to evolve in a more flexible manner than typically possible in a relational setting, particularly for capturing incomplete knowledge. Unlike (other) NoSQL models, specialised graph query languages support not only standard relational operators (joins, unions, projections, etc.), but also navigational operators for recursively finding entities connected through arbitrary-length paths . Standard knowledge representation formalisms – such as ontologies and rules – can be employed to define and reason about the semantics of the terms used to label and describe the nodes and edges in the graph. Scalable frameworks for graph analytics can be leveraged for computing centrality, clustering, summarisation, etc., in order to gain insights about the domain being described. Various representations have also been developed that support applying machine learning techniques directly over graphs."\cite{hogan2021knowledge}
%\end{quote}
In the article, they outline graph data models (for example \textit{RDF}), query languages (for example \textit{SPARQL}), representations of schema (for example \textit{RDFS} and \textit{SHACL}), knowledge deduction (for example with \textit{OWL}) and much more.
We introduce those in the following subsections.



\subsubsection{Resource Description Framework (RDF)}
RDF is a standard for establishing semantic interoperability on the Web. 
It provides a data model that can be extended to address sophisticated ontology representation techniques.
The basic building block in RDF is an \textit{object-attribute-value} triple\cite{decker2000semantic}, also referred to as a \textit{subject-predicate-object} triple \cite{hogan2021knowledge}.
There are different notations for a triple, for example \textit{Attribute(Object,Value)} and \textit{(subject, predicate, object)}.
See listing \ref{lst:rdf-triple-example} for example data using those notations.
A set of RDF triples represents a labeled, directed graph, with every triple representing an edge \texttt{[s]-p->[o]}.
The subjects and objects of the triples are the nodes in the graph.
%It is possible for a predicate IRI to also occur as a node in the same graph.\cite{w3c_rdf}


\begin{lstlisting}[language=json,basicstyle=\scriptsize,firstnumber=1,caption={Different notations for an RDF triple},captionpos=b,label={lst:rdf-triple-example}]
// A(O,V)
example.org:firstName('example.org/person42', 'Alex'}
example.org:lastName('example.org/person42', 'Smith'}

// (s, p, o)
('example.org/person42', example.org/firstName, 'Alex)
('example.org/person42', example.org/lastName, 'Smith)
\end{lstlisting}


To unambiguously identify objects and vocabulary terms, a uniform resource identifier (URI)\cite{berners2005uniform} or internationalized resource identifier (IRI, an extension of URI)\cite{rfc3987} is used.
For every triple, the \textit{subject} is an IRI or a blank node.
The \textit{predicate} is an IRI and the \textit{object} is an IRI, a literal or a blank node.
Blank nodes are nodes without an IRI, also called anonymous resources.
To abbreviate IRIs to qualified names, RDF syntaxes use namespaces.\cite{w3c_rdf}
Machine readable data formats for RDF are in XML\cite{rdf_xml_syntax}, Turtle\cite{beckett2014rdf}, JSON-LD\cite{sporny2020json} and others\cite{ntriples, nquads, trig, grlicky2005overview}.
Listing \ref{lst:rdf-turtle-example} shows our example triple from listing \ref{lst:rdf-triple-example} in Turtle syntax, using namespaces.
% Listing \ref{lst:rdf-jsonld-example} shows it in JSON-LD syntax.
Figure \ref{fig:rdf_graph} visualizes the RDF graph\footnote{\label{footnote:graph_visualizer}The graph was visualized using \url{https://www.ldf.fi/service/rdf-grapher}, accessed 2024/04/30.}.

\begin{lstlisting}[language=json,basicstyle=\scriptsize,firstnumber=1,caption={RDF Graph in Turtle syntax},captionpos=b,label={lst:rdf-turtle-example}]
@prefix ex: <http://example.org/> .

ex:person42 ex:firstName "Alex" .
ex:person42 ex:lastName "Smith" .
\end{lstlisting}


\begin{figure}[!t]
    \centering
    \includegraphics[width=\columnwidth]{figures/rdf_graph_example}
    \caption{Visualization of the RDF graph defined in listing \ref{lst:rdf-turtle-example}}
    \label{fig:rdf_graph}
\end{figure}

RDF uses XML Schema datatypes for literal values, as shown in listing \ref{lst:rdf-literals-datatype}.


\begin{lstlisting}[language=json,basicstyle=\scriptsize,firstnumber=1,caption={Usage of XML Schema datatypes for literals in RDF},captionpos=b,label={lst:rdf-literals-datatype}]
@prefix ex: <http://example.org/> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .

ex:person42 ex:birthDate "1996-05-26"^^xsd:date .
\end{lstlisting}

To define the \textit{type} (also called \textit{class} or \textit{concept}) that an object is an instance of, the \textit{type} predicate of the \textit{rdf} namespace is used, as shown in listing \ref{lst:rdf-type}.
In the same manner, predicates and concepts from existing namespaces can be used, avoiding the need for repeating the work that others already have done and leading to shared vocabulary and interoperability.
% TODO: Quote paper on how many ontologies exist

\begin{lstlisting}[language=json,basicstyle=\scriptsize,firstnumber=1,caption={Type definition in RDF},captionpos=b,label={lst:rdf-type}]
@prefix ex: <http://example.org/> .
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .

ex:person42 rdf:type ex:Person .
\end{lstlisting}

For example, \textit{friend of a friend} (\textit{FOAF})\cite{brickley2007foaf} is an ontology for modeling social networks and already contains the predicates \textit{firstName} and \textit{lastName}, as well as the concept \textit{Person}.
Instead of defining our own predicates and concepts in the \textit{https://example.org} namespace, we can use the ones from \textit{FOAF}.
Also, the \texttt{rdf:type} predicate can be abbreviated with "\texttt{a}".
Furthermore, when defining multiple predicates and objects for a subject, we can use a shortened syntax in Turtle.
When we apply all of these points, we end up with the RDF graph definition shown in listing \ref{lst:rdf-example-final}. 
Figure \ref{fig:rdf_graph_final} shows the visualized RDF graph\footnote{See footnote \ref{footnote:graph_visualizer}.}.

\begin{lstlisting}[language=json,basicstyle=\scriptsize,firstnumber=1,caption={Complete RDF example},captionpos=b,label={lst:rdf-example-final}]
@prefix ex: <http://example.org/> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix foaf: <http://xmlns.com/foaf/0.1/> .

ex:person42 a               foaf:Person ;
            foaf:firstName  "Alex" ;
            foaf:lastName   "Smith" ;
            ex:birthDate    "1996-05-26"^^xsd:date .
\end{lstlisting}


\begin{figure}[!t]
    \centering
    \includegraphics[width=\columnwidth]{figures/rdf_graph_example_final}
    \caption{Visualization of the RDF graph defined in listing \ref{lst:rdf-example-final}}
    \label{fig:rdf_graph_final}
\end{figure}



\subsubsection{SPARQL Protocol and RDF Query Language (SPARQL)}
SPARQL\cite{sparql} is the standard language for querying RDF data\cite{perez2009semantics}.  
Most forms of SPARQL query contain a set of triple patterns, which are like RDF triples, except that the subject, predicate and object may each be a variable.
The syntax is SQL-like, as shown in listing \ref{lst:sparql_syntax}.

\begin{lstlisting}[language=json,basicstyle=\scriptsize,firstnumber=1,caption={Syntax of a SPARQL query},captionpos=b,label={lst:sparql_syntax}]
SELECT <variables>
FROM <graphs>
WHERE { <triple patterns> }
\end{lstlisting}

A query returns a set of variable bindings as result.
For example, the query shown in listing \ref{lst:sparql_example_query} returns the variable bindings shown in table \ref{tab:sparql_example_result}, given the RDF graph defined in listing \ref{lst:rdf-example-final}.
It binds every subject to the \texttt{?person} variable, for which there exists a triple with the \texttt{rdf:type} predicate and the \texttt{foaf:Person} object.
Also, there must exist a triple with the same subject and a \texttt{foaf:firstName} predicate, as well as one with a \texttt{foaf:lastName} predicate.
For all subjects, where this is the case, the variable bindings for \texttt{?firstName} and \texttt{?lastName} are returned.

\begin{lstlisting}[language=json,basicstyle=\scriptsize,firstnumber=1,caption={Example SPARQL query},captionpos=b,label={lst:sparql_example_query}]
SELECT ?firstName ?lastName
WHERE {
    ?person  rdf:type         foaf:Person .
    ?person  foaf:firstName   ?firstName .
    ?person  foaf:lastName    ?lastName .
}
\end{lstlisting}

\begin{table}[]
\caption{Variable bindings for the query in listing \ref{lst:sparql_example_query} on the graph defined in listing \ref{lst:rdf-example-final}}
\label{tab:sparql_example_result}
\centering\scriptsize
\begin{tabular}{@{}ll@{}}
\toprule
\textbf{?firstName} & \textbf{?lastName} \\ \midrule
"Alex"              & "Smith"           
\end{tabular}
\end{table}

SPARQL supports advanced features, such as \textit{filters}, \textit{group graph patterns}, \textit{optional graph patterns}, \textit{union graph patterns}, \textit{ordering}, \textit{limit}, \textit{offset} and more.
It supports other verbs besides \textit{SELECT}, such as \textit{CONSTRUCT} to dynamically construct a graph, or \textit{ASK} to check whether the query pattern has a solution.


\subsubsection{RDF Schema (RDFS)}
RDFS\cite{RDFS} is a simple ontology and schema language for RDF. 
It is an RDF vocabulary and contains concepts and properties for defining concepts or properties and their characteristics.
Listing \ref{lst:rdfs_example} provides an example, where RDFS is used to make \texttt{foaf:Person} a subclass of \texttt{ex:LivingBeing} and to define the range and domain of the \texttt{ex:birthDate} property.
Because of being a subclass of it, every \texttt{foaf:Person} inherits the properties of \texttt{ex:LivingBeing}.
Furthermore, because of the range and domain definition, for every tuple that has \texttt{ex:birthDate} as predicate, the subject must be a living being (domain) and the object must be a date (range).
Although they are defined as part of the RDF namespace, the terms \texttt{rdf:type} and \texttt{rdf:Property} are part of RDFS too.
Analogous to \texttt{rdfs:subClassOf}, the hierarchy of properties can be specified using the term \texttt{rdfs:subPropertyOf}.

\begin{lstlisting}[language=json,basicstyle=\scriptsize,firstnumber=1,caption={RDFS example},captionpos=b,label={lst:rdfs_example}]
@prefix ex: <http://example.org/> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .
@prefix foaf: <http://xmlns.com/foaf/0.1/> .

foaf:Person   rdfs:subClassOf   ex:LivingBeing .
ex:birthDate  rdfs:domain       ex:LivingBeing ;
              rdfs:range        xsd:date .
\end{lstlisting}

\subsubsection{Shapes Constraint Language (SHACL)}
SHACL\cite{SHACL} is a schema language for RDF that is more expressive than RDFS.
It validates an RDF graph against a set of so-called \textit{shapes} and allows expressing complex constraints.
Each shape declares targets (which nodes need to confirm to this shape), constraints and rules (what constraints do the target nodes have and which rules do they need to confirm to).
Listing \ref{lst:shacl_example} shows an example shape that forces every node of type \texttt{foaf:Person} to have exactly one birth date as property, being of type \texttt{xsd:date}.
Restricting the amount of properties that a node can or must have is something that is not possible using only RDFS.

SHACL focuses on data validation, based on the \textit{closed-world assumption} (missing information is assumed to be false) and the \textit{unique-name assumption} (distinct names refer to distinct objects).\cite{steffen_staab_lecture_slides}

\begin{lstlisting}[language=json,basicstyle=\scriptsize,firstnumber=1,caption={SHACL example shape},captionpos=b,label={lst:shacl_example}]
@prefix ex: <http://example.org/> .
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .
@prefix foaf: <http://xmlns.com/foaf/0.1/> .
@prefix sh: <http://www.w3.org/ns/shacl#> .

ex:PersonShape   rdf:type          sh:NodeShape ;
                 sh:targetClass    foaf:Person ;
                 sh:property [
                     sh:path      foaf:firstName ;
                     sh:minCount  1 ;
                     sh:maxCount  1 ;
                     sh:datatype  xsd:date ;
                 ] .
\end{lstlisting}



\subsubsection{Web Ontology Language (OWL)}
OWL \cite{OWL} is an ontology language for authoring ontologies.
It allows expressing complex concept descriptions.
Contrary to SHACL, the focus is less on data validation and more on inference (of new knowledge), based on the \textit{open-world assumption} (missing information is assumed to be unknown) and \textit{no unique-names assumption} (distinct names can refer to same object).\cite{steffen_staab_lecture_slides}

This work does not discuss SHACL or OWL any further and does not make use of them. 
They are introduced for the sake of completeness only.



\subsubsection{JavaScript Object Notation for Linked Data (JSON-LD)}
JSON-LD~\cite{json-ld} is a syntax to serialize graphs in JSON. 
It is fully compatible with JSON and introduces an \textit{identifier mechanism} for JSON objects  (via IRIs), a way for \textit{disambiguating keys} shared among different JSON documents by mapping them to IRIs via a \textit{context}, a mechanism in which a \textit{value} of a JSON object \textit{may refer to a resource} and more.
The data model described by a JSON-LD document is an RDF graph. 
It can be combined with other RDF technology, such as SPARQL, but it can also be used without knowledge of RDF.
JSON-LD specifies a number of keywords (the following list is incomplete):
\begin{itemize}
	\item \textbf{@base} - used to set the base IRI, against which to resolve relative IRIs
	\item \textbf{@context} - used to define short-hand names, called \textit{terms}
	\item \textbf{@container} - used to set the default container for a \textit{term}
	\item \textbf{@graph} - used to express a graph
	\item \textbf{@id} - used to uniquely identify node objects that are being described with IRIs or \textit{blank node identifiers}
	\item \textbf{@type} - used to set the type of a node or the datatype of a typed value
	\item \textbf{@value} - used to specify the data that is associated with a particular property in the graph
	\item \textbf{@list} - used to express an ordered set of data
	\item \textbf{@set} - used to prepare an unordered set of data
\end{itemize}


\subsection{MetaConfigurator}

